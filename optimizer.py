import numpy as np
import matplotlib.pyplot as plt

class LSTPOptimizer:
    """Grid-search optimizer for stop-loss / take-profit strategies.

    Parameters
    ----------
    simulator
        An instance of :class:`GBMSimulator` with precomputed simulations.
    sl_min, sl_max, tp_min, tp_max
        Fractional bounds for the stopping levels expressed relative to
        ``simulator.s0``. The actual prices will be generated by
        multiplying these fractions by the initial price.
    step
        Grid step size for both stop-loss and take-profit ranges.
    fee_rate
        Constant trading fee subtracted from each simulated return.
    """

    def __init__(
        self,
        simulator,
        sl_min: float = 0.1,
        sl_max: float = 0.95,
        tp_min: float = 1.05,
        tp_max: float = 5,
        step: float = 0.05,
        fee_rate: float = 0.005,
    ):
        self.sl_range: np.ndarray = np.arange(sl_min, sl_max + step, step)
        self.tp_range: np.ndarray = np.arange(tp_min, tp_max + step, step)
        self.simulator = simulator
        self.SL_grid, self.TP_grid = np.meshgrid(self.sl_range, self.tp_range)

        self.returns: np.ndarray | None = None
        self.mean_ret: np.ndarray | None = None
        self.std_ret: np.ndarray | None = None
        self.sharpe_ratio: np.ndarray | None = None

        self.best_returns: np.ndarray | None = None
        self.idx_best: int | None = None
        self.best_sl: float | None = None
        self.best_tp: float | None = None
        self.fee_rate: float = fee_rate

    def calculate_metrics(self) -> None:
        """Compute return statistics and Sharpe ratios for each grid point.

        The method populates ``self.returns``, ``self.mean_ret``,
        ``self.std_ret`` and ``self.sharpe_ratio`` using the simulated
        price series already stored on the provided simulator.
        """
        sl_flat = self.SL_grid.flatten() * self.simulator.s0
        tp_flat = self.TP_grid.flatten() * self.simulator.s0

        prices_3d = self.simulator.prices_series[:, :, np.newaxis]

        mask_sl = prices_3d <= sl_flat
        mask_tp = prices_3d >= tp_flat
        mask_trigger = mask_sl | mask_tp

        exit_indices = np.argmax(mask_trigger, axis=0)
        # determine if an exit occurred in each simulation/strategy pair
        any_trigger = mask_trigger.any(axis=0)  # shape (n_sims, n_strategies)
        # if no trigger, use last index (-1)
        actual_exit_indices = np.where(any_trigger, exit_indices, -1)

        # create array of simulation indices for advanced indexing
        sim_indices = np.arange(self.simulator.n_sims)[:, np.newaxis]
        final_wealth = self.simulator.prices_series[actual_exit_indices, sim_indices]

        self.returns = ((final_wealth - self.simulator.s0) / self.simulator.s0) - self.fee_rate
        self.mean_ret = self.returns.mean(axis=0)
        self.std_ret = self.returns.std(axis=0)
        self.sharpe_ratio = self.mean_ret / self.std_ret

    def get_optimized_params(self) -> tuple[float, float]:
        """Return the stop-loss and take-profit values that maximize Sharpe.

        The optimization is run if necessary by calling
        :meth:`calculate_metrics` internally. The results are cached on the
        object for later inspection.
        """
        if self.sharpe_ratio is None:
            self.calculate_metrics()

        self.idx_best = int(np.argmax(self.sharpe_ratio))
        self.best_sl = float(self.SL_grid.flatten()[self.idx_best])
        self.best_tp = float(self.TP_grid.flatten()[self.idx_best])
        self.best_returns = self.returns[:, self.idx_best]

        return self.best_sl, self.best_tp

    def optimize(self) -> tuple[float, float]:
        """Convenience wrapper that runs the full optimization pipeline.

        After calling this method the optimizer will have ``best_sl``,
        ``best_tp`` and ``best_returns`` populated.  Returns the optimal
        (sl, tp) pair.
        """
        return self.get_optimized_params()

    def plot_optimal_equity_curve(self) -> None:
        """Plot the average equity trajectory using the optimal parameters.

        Requires that ``optimize()`` has been called first.
        """
        if self.best_sl is None or self.best_tp is None:
            raise RuntimeError("No optimized parameters available; call optimize() first")

        equity_curves = self.simulator.apply_sl_tp(
            stop_loss=self.best_sl * self.simulator.s0,
            take_profit=self.best_tp * self.simulator.s0,
        )
        average_equity = equity_curves.mean(axis=1)

        plt.figure(figsize=(10, 5))
        plt.plot(average_equity, label="Average Equity (Optimized)", color="gold")
        plt.axhline(y=self.simulator.s0, color="red", linestyle="--", label="Initial Capital")
        plt.title("Average Equity Evolution - Optimal Strategy")
        plt.xlabel("Time step")
        plt.ylabel("Equity")
        plt.legend()
        plt.grid(True)
        plt.show()

        # mean_ret_2d = mean_ret.reshape(SL_grid.shape)
        # plt.imshow(mean_ret_2d, extent=[0.5, 0.95, 1.05, 2.0], origin="lower")
        # plt.colorbar(label="Rendement Moyen")
        # plt.xlabel("Stop Loss (fraction du prix)")
        # plt.ylabel("Take Profit (fraction du prix)")
        # plt.title("Optimisation de la stratÃ©gie SL/TP sur Bitcoin")
        # plt.show()
    
    @property
    def best_win_rate(self) -> float:
        """Proportion of profitable simulations for the best strategy."""
        if self.best_returns is None:
            raise RuntimeError("Call optimize() or get_optimized_params() first")
        return float((self.best_returns > 0).mean())

    def plot_sharpe_ratio(self) -> None:
        """Display a heatmap of Sharpe ratio over the SL/TP grid."""
        if self.sharpe_ratio is None:
            raise RuntimeError("Metrics have not been calculated; call optimize() first")
        sharpe_ratio_2d = self.sharpe_ratio.reshape(self.SL_grid.shape)
        plt.imshow(
            sharpe_ratio_2d,
            extent=[self.sl_range.min(), self.sl_range.max(), self.tp_range.min(), self.tp_range.max()],
            origin="lower",
        )
        plt.colorbar(label="Sharpe ratio")
        plt.xlabel("Stop Loss (fraction of price)")
        plt.ylabel("Take Profit (fraction of price)")
        plt.title("SL/TP Sharpe Heatmap")
        plt.show()